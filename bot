#!/home/mute/bin/tclsh8.3

set ::mynick neutronbot,neutrontcl
set ::sasl_user mute
set ::sasl_pass [exec cat sekret]

# basically a comment of what I was running to test it each iteration
set TEST_PROCEDURE {
show event manager policy active
event manager scheduler clear policy 5
copy http://150.136.80.131/downloads/tclbot flash:/policies/bot.tcl
conf t
no event manager policy bot.tcl
event manager policy bot.tcl
end
event manager run bot.tcl
}

# catch this so I can run it on non-cisco tclsh without issue
catch {::cisco::eem::event_register_none maxrun 31536000}

# flood control: safe defaults.
# allowance is increased by RATE units each second
# each message costs PER units. MAX should be 5*PER to allow a burst of 5 messages.
variable ::sendq_RATE 5 ::sendq_PER 8 ::sendq_MAX 40

variable ::conn_state disconnected

proc save_info {} {
  set out [open "info.txt" w]
  puts $out [array get ::info]
  close $out
}

proc load_info {} {
  catch {
    set in [open "info.txt"]
    array set ::info [read $in]
    close $in
  }
}

proc send {line} {
  puts ">>> $line"
  puts $::fd $line
  flush $::fd
}

proc sendq {line} {
  lappend ::sendq $line
}

proc sendq_dowork {} {
  incr ::sendq_allowance $::sendq_RATE
  if {$::sendq_allowance > $::sendq_MAX} {
    set ::sendq_allowance $::sendq_MAX
  }

  if {![llength $::sendq]} {return}

  while {[llength $::sendq] > 0 && $::sendq_allowance >= $::sendq_PER} {
    send "[lindex $::sendq 0]"
    set ::sendq [lrange $::sendq 1 end]
    set ::sendq_allowance [expr {$::sendq_allowance - $::sendq_PER}]
  }
}

proc recv {} {
  gets $::fd line
  if {[eof $::fd]} {
    irc_disconnect
    return
  }

  if {![regexp -- {:(\S+) (\S+) (\S+)(?: :?(.*))?} $line -> src cmd dst rest]} {
    set src {}
    set dst {}
    regexp -- {(\S+) :?(.*)} $line -> cmd rest
  }
  if {![info exists cmd]} {
    puts "no cmd parsed: $line"
    return -1
  }

  switch $cmd {
    002 - 003 - 004 - 005 - 250 - 251 - 252 - 253 - 254 - 
    255 - 265 - 266 - 332 - 333 - 372 - 375 - 376 {
      # saves from printing in default action because we don't care.
    }
    PING {send "PONG :$rest"}
    PRIVMSG {cmd_privmsg $src $dst $rest}
    001 {sendq "JOIN :#mute"}
    433 send_nick

    CAP {sendq "AUTHENTICATE PLAIN"}
    AUTHENTICATE send_sasl
    903 {sendq "CAP END"}
    904 {exit}

    default {puts "<<< $line"}
  }
}

proc reply {nick dst msg} {
  if {$dst == $::curnick} {
    sendq "PRIVMSG $nick :$msg"
  } else {
    sendq "PRIVMSG $dst :$nick: $msg"
  }
}

proc cmd_privmsg {src dst msg} {
  set nick [string range $src 0 [expr [string first ! $src] - 1]]
  puts "::: \[$dst\] <$nick> $msg"

  if {$dst == $::curnick && $nick == "mute" && [string match {eval *} $msg]} {
    regexp -- {eval (.*)} $msg -> msg
    catch $msg result
    foreach line [split $result \n] {
      sendq "PRIVMSG mute :$line"
    }
    return
  }

  if {[string match -nocase "$::curnick:*" $msg]} {
    regexp -- {\S+: ?(.*)} $msg -> msg
  } elseif {$dst == $::curnick} {
    # continue
  } else {
    return
  }

  if {[regexp -nocase -- {^(?:what is\s+)?(\S+?)\??$} $msg -> word]} {
    puts "--- word($word)"
    if {[info exists ::info($word)]} {
      reply $nick $dst $::info($word)
    } else {
      reply $nick $dst "I don't know."
    }
  } elseif {[regexp -nocase -- {^(\S+)\s+is\s+(.*)} $msg -> word def]} {
    set ::info($word) $def
    save_info
  }
}

proc send_nick {} {
  set nickarr [split $::mynick ,]

  if {$::nicknum >= [llength $nickarr]} {
    set ::curnick [lindex $nickarr 0]$::nicknum
  } else {
    set ::curnick [lindex $nickarr $::nicknum]
  }
  sendq "NICK $::curnick"
  incr ::nicknum
}

proc send_sasl {} {
  if {![info exists ::sasl_computed]} {
    set ::sasl_computed [base64_encode "$::sasl_user\0$::sasl_user\0$::sasl_pass"]
  }
  for {set i 0} {$i < [string length $::sasl_computed]} {incr i 400} {
    sendq "AUTHENTICATE [string range $::sasl_computed $i [expr {$i + 400}]]"
  }
  if {[string length $::sasl_computed] == $i} {
    sendq "AUTHENTICATE +"
  }
}

proc base64_encode {str} {
  set base64_en {
    A B C D E F G H I J K L M N O P Q R S T U V W X Y Z \
    a b c d e f g h i j k l m n o p q r s t u v w x y z \
    0 1 2 3 4 5 6 7 8 9 + /
  }
  set result {}
  binary scan $str c* X
  foreach {x y z} $X {
    set u [expr {$x<<16|[expr {$y!={}?$y:0}]<<8|[expr {$z!={}?$z:0}]}]
    append result [lindex $base64_en [expr {$u>>18}]]
    append result [lindex $base64_en [expr {$u>>12&63}]]
    append result [expr {$y=={}?"=":[lindex $base64_en [expr {$u>>6&63}]]}]
    append result [expr {$z=={}?"=":[lindex $base64_en [expr {$u&63}]]}]
  }
  return $result
}

proc bgerror message {
  puts stderr ":::error::: $message"
}

proc irc_disconnect {} {
  close $::fd
  set ::conn_state disconnected
  set ::sendq {}
  after 10000 {irc_connect}
}

proc irc_connect {} {
  set ::nicknum 0
  set ::sendq_allowance $::sendq_MAX
  set ::sendq {}

  set ::fd [socket irc.libera.chat 6667]
  set ::conn_state connected

  sendq "CAP REQ :sasl"
  send_nick
  sendq "USER tcl 0 * :tclbot"

  fileevent $::fd readable recv
}

proc main {} {
  load_info
  irc_connect

  while {1} {
    after 1000 {set timeout 1}
    vwait timeout
    sendq_dowork
  }
}

main
